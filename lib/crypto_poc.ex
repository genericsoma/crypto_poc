defmodule CryptoPoc do
  @moduledoc """
  POC of transport encryption.
  """

  require Integer
  import Bitwise

  @key_size 256

  @doc """
  Encrypt `msg` using `key`, returns base64 encoded result.
  """
  def encrypt(key, msg) when bit_size(key) == @key_size do
    {:ok, {iv, cipher_text}} = ExCrypto.encrypt(key, msg)
    Base.encode64(iv <> cipher_text)
  end

  @doc """
  Decrypts base64-encoded payload from `msg64`, returns original message.
  """
  def decrypt(key, msg64) when bit_size(key) == @key_size do
    {:ok, <<iv:: binary-size(16), cipher_text:: binary>>} = Base.decode64(msg64)
    {:ok, plain_text} = ExCrypto.decrypt(key, iv, cipher_text)
    plain_text
  end

  defp b2n(<<>>, r), do: r
  defp b2n(<<b, t:: binary>>, r), do: b2n(t, r * 256 + b)

  def bitstr_to_num(s) do
    s |> String.reverse |> b2n(0)
  end

  defp n2b(0, <<>>), do: <<0>>
  defp n2b(0, r), do: r
  defp n2b(n, r) do
    r = <<rem(n, 256)>> <> r
    n2b(n >>> 8, r)
  end

  def num_to_bitstr(n) do
    n |> n2b(<<>>)
  end


  # Safe prime generated by openssl dhparam -C 1024
  def dh_p, do: 
      0xABBA88AB3D950BCDDC94230A_A01AA9987D69AC0E71B4A4B9_BDA56582DABE6DF4933FAEAB_718006B44F1D2633EF20DBFB_064B9815FD873AB077890821_1D7E9B6666650236618E98AA_12E34AFCF0A2165F4108B447_DCCF818D51E5506FAC4B0632_23F0B74FE723ADA037EBE263_F7BF483635319E0D1D424A48_0A651B6BCA702FDB

  # Generator
  @dh_g 4

  def pow(_, 0), do: 1
  def pow(a, b) do
    if Integer.is_even(b) do
      pow(a * a, div(b, 2))
    else
      a * pow(a, b - 1)
    end
  end

  def modexp(b, e, m), do: modexp(b, e, m, 1)

  defp modexp(_b, 0, _m, r), do: r
  defp modexp(b, e, m, r) do
    b = rem(b, m)
    r = if rem(e, 2) == 1 do
      rem(r * b, m)
    else
      r
    end
    e = e >>> 1
    b = b * b
    modexp(b, e, m, r)
  end

  def dh_exp_p(g, a) do
    modexp(g, a, dh_p())
  end

  @doc """
  Generates a DH secret-public pair.
  """
  def dh_pair do
    aS = ExCrypto.rand_int(2, dh_p() - 2)
    aP = dh_exp_p(@dh_g, aS)
    {aS, aP}
  end

  @doc """
  Returns the shared secret key (as binary) for a public `bP`. The key is a SHA256 of DH result.
  """
  def dh_key(bP, aS) do
    {:ok, key} = dh_exp_p(bP, aS) |> num_to_bitstr |> ExCrypto.Hash.sha256
    key
  end

  def start_link do
    {:ok, agent_pid} = Agent.start_link(fn -> %{} end, name: __MODULE__)
    proc_pid = spawn_link __MODULE__, :handler, []
    IO.puts "agent,proc started"
    Process.register(proc_pid, :crypto_poc_proc)
    agent_pid
  end

  def get_key(id) do
    IO.puts "obtain key for id: " <> id
    {key, _} = Agent.get(__MODULE__, fn m -> Map.get(m, id) end)
    key
  end

  def register_key(id, key, timeout \\ :infinity) do
    IO.puts "register key for id: " <> id
    timer_pid = if timeout != :infinity do
      set_timeout(id, timeout)
    else
      nil
    end
    Agent.update(__MODULE__, fn m -> Map.put(m, id, {key, timer_pid}) end)
  end

  def forget_key(id) do
    IO.puts "deleting key for id: " <> id
    case Agent.get_and_update(__MODULE__, fn m -> Map.pop(m, id) end) do
      {_, nil} -> :ok
      {_, timer_pid} -> Process.cancel_timer(timer_pid)
      _ ->
        IO.puts "error deleting key"
        :error
    end
  end

  def handler do
    receive do
      {:timeout, id} ->
        forget_key(id)
        handler()
      {:shutdown} -> shutdown()
      msg ->
        IO.puts "unknown message: " <> inspect(msg)
        handler()
    end
  end

  def set_timeout(id, timeout) do
    Process.send_after(:crypto_poc_proc, {:timeout, id}, timeout)
  end

  def shutdown do
    IO.puts "shutting down"
    Agent.stop(__MODULE__)
    send :crypto_poc_proc, {:shutdown}
    Process.unregister(:crypto_poc_proc)
  end
end
